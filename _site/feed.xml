<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Umut Dogan</title>
    <description>Software Developer - Consultant</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 31 Oct 2018 22:28:29 +0300</pubDate>
    <lastBuildDate>Wed, 31 Oct 2018 22:28:29 +0300</lastBuildDate>
    <generator>Jekyll v3.7.4</generator>
    
      <item>
        <title>Algorithms</title>
        <description>&lt;p&gt;In mathematics and computer science, an algorithm is an unambiguous specification of how to solve a class of problems. Algorithms can perform calculation, data processing and automated reasoning tasks.&lt;/p&gt;

&lt;p&gt;As an effective method, an algorithm can be expressed within a finite amount of space and time and in a well-defined formal language for calculating a function. Starting from an initial state and initial input (perhaps empty), the instructions describe a computation that, when executed, proceeds through a finite number of well-defined successive states, eventually producing “output” and terminating at a final ending state. The transition from one state to the next is not necessarily deterministic; some algorithms, known as randomized algorithms, incorporate random input.&lt;/p&gt;

&lt;p&gt;The concept of algorithm has existed for centuries. Greek mathematicians used algorithms in, for example, the sieve of Eratosthenes for finding prime numbers and the Euclidean algorithm for finding the greatest common divisor of two numbers.&lt;/p&gt;

&lt;p&gt;The word algorithm itself derives from the 9th Century mathematician Muḥammad ibn Mūsā al-Khwārizmī. A partial formalization of what would become the modern concept of algorithm began with attempts to solve the Entscheidungsproblem (decision problem) posed by David Hilbert in 1928. Later formalizations were framed as attempts to define “effective calculability” or “effective method”. Those formalizations included the Gödel–Herbrand–Kleene recursive functions of 1930, 1934 and 1935, Alonzo Church’s lambda calculus of 1936, Emil Post’s Formulation 1 of 1936, and Alan Turing’s Turing machines of 1936–37 and 1939.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;a href=&quot;https://xkcd.com/26/&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;../../images/2018-10-31-algorithms.jpg&quot; alt=&quot;Fourier&quot; title=&quot;Fourier&quot; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h2 id=&quot;design&quot;&gt;Design&lt;/h2&gt;
&lt;p&gt;Algorithm design refers to a method or mathematical process for problem solving and engineering algorithms. The design of algorithms is part of many solution theories of operation research, such as dynamic programming and divide-and-conquer. Techniques for designing and implementing algorithm designs are also called algorithm design patterns, such as the template method pattern and decorator pattern.&lt;/p&gt;

&lt;p&gt;One of the most important aspects of algorithm design is creating an algorithm that has an efficient run-time, also known as its Big O.&lt;/p&gt;

&lt;p&gt;Typical steps in development of algorithms:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Problem definition&lt;/li&gt;
  &lt;li&gt;Development of a model&lt;/li&gt;
  &lt;li&gt;Specification of algorithm&lt;/li&gt;
  &lt;li&gt;Designing an algorithm&lt;/li&gt;
  &lt;li&gt;Checking the correctness of algorithm&lt;/li&gt;
  &lt;li&gt;Analysis of algorithm&lt;/li&gt;
  &lt;li&gt;Implementation of algorithm&lt;/li&gt;
  &lt;li&gt;Program testing&lt;/li&gt;
  &lt;li&gt;Documentation preparation&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;example&quot;&gt;Example&lt;/h2&gt;
&lt;p&gt;One of the simplest algorithms is to find the largest number in a list of numbers of random order. Finding the solution requires looking at every number in the list. From this follows a simple algorithm, which can be stated in a high-level description English prose, as:&lt;/p&gt;

&lt;p&gt;High-level description:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;If there are no numbers in the set then there is no highest number.&lt;/li&gt;
  &lt;li&gt;Assume the first number in the set is the largest number in the set.&lt;/li&gt;
  &lt;li&gt;For each remaining number in the set: if this number is larger than the current largest number, consider this number to be the largest number in the set.&lt;/li&gt;
  &lt;li&gt;When there are no numbers left in the set to iterate over, consider the current largest number to be the largest number of the set.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;algorithmic-analysis&quot;&gt;Algorithmic Analysis&lt;/h2&gt;
&lt;p&gt;It is frequently important to know how much of a particular resource (such as time or storage) is theoretically required for a given algorithm. Methods have been developed for the analysis of algorithms to obtain such quantitative answers (estimates).&lt;/p&gt;

&lt;h2 id=&quot;classification&quot;&gt;Classification&lt;/h2&gt;
&lt;p&gt;There are various ways to classify algorithms:&lt;/p&gt;

&lt;h3 id=&quot;by-implementation&quot;&gt;By implementation&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Recursion&lt;/li&gt;
  &lt;li&gt;Logical&lt;/li&gt;
  &lt;li&gt;Serial, parallel or distributed&lt;/li&gt;
  &lt;li&gt;Deterministic or non-deterministic&lt;/li&gt;
  &lt;li&gt;Exact or approximate&lt;/li&gt;
  &lt;li&gt;Quantum algorithm&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;by-design-paradigm&quot;&gt;By design paradigm&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Brute-force or exhaustive search&lt;/li&gt;
  &lt;li&gt;Divide and conquer&lt;/li&gt;
  &lt;li&gt;Search and enumeration&lt;/li&gt;
  &lt;li&gt;Randomized algorithm&lt;/li&gt;
  &lt;li&gt;Reduction of complexity&lt;/li&gt;
  &lt;li&gt;Back tracking&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;optimization-problems&quot;&gt;Optimization problems&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Linear programming&lt;/li&gt;
  &lt;li&gt;Dynamic programming&lt;/li&gt;
  &lt;li&gt;The greedy method&lt;/li&gt;
  &lt;li&gt;The heuristic method&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;by-field-of-study&quot;&gt;By field of study&lt;/h3&gt;
&lt;p&gt;Every field of science has its own problems and needs efficient algorithms. Related problems in one field are often studied together. Some example classes are search algorithms, sorting algorithms, merge algorithms, numerical algorithms, graph algorithms, string algorithms, computational geometric algorithms, combinatorial algorithms, medical algorithms, machine learning, cryptography, data compression algorithms and parsing techniques.&lt;/p&gt;

&lt;h3 id=&quot;by-complexity&quot;&gt;By complexity&lt;/h3&gt;
&lt;p&gt;Algorithms can be classified by the amount of time they need to complete compared to their input size:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Constant time&lt;/li&gt;
  &lt;li&gt;Linear time&lt;/li&gt;
  &lt;li&gt;Logarithmic time&lt;/li&gt;
  &lt;li&gt;Polynomial time&lt;/li&gt;
  &lt;li&gt;Exponential time&lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&quot;references&quot;&gt;References:&lt;/h6&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Algorithm&quot;&gt;https://en.wikipedia.org/wiki/Algorithm&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.geeksforgeeks.org/fundamentals-of-algorithms&quot;&gt;https://www.geeksforgeeks.org/fundamentals-of-algorithms&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&quot;books&quot;&gt;Books:&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844&quot;&gt;Introduction to Algorithms, 3rd Edition (The MIT Press)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X&quot;&gt;Algorithms (4th Edition)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.amazon.com/Data-Structures-Algorithms-Java-6th-ebook/dp/B00JDRQF8C&quot;&gt;Data Structures and Algorithms in Java, 6th Edition&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 31 Oct 2018 01:00:23 +0300</pubDate>
        <link>http://localhost:4000/2018/algorithms/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/algorithms/</guid>
        
        <category>algorithms</category>
        
        
        <category>algorithms</category>
        
      </item>
    
      <item>
        <title>Software Design Patterns</title>
        <description>&lt;p&gt;Design pattern is a general repeatable solution to a commonly occurring problem in software design. A design pattern isn’t a finished design that can be transformed directly into code. It is a description or template for how to solve a problem that can be used in many different situations.&lt;/p&gt;

&lt;p&gt;If you are new to programming, probably you won’t hear or use “design pattern” concept a lot for the first couple months/years. But after some time, when you start to write more meaningful programs, you’ll definitely need to use some tested and proven design patterns in your code. Design patterns can speed up the development process by providing tested, proven development paradigms. Effective software design requires considering issues that may not become visible until later in the implementation. Reusing design patterns helps to prevent subtle issues that can cause major problems and improves code readability for coders and architects familiar with the patterns.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;../../images/2018-07-05-software-design-patterns.jpg&quot; alt=&quot;Design Patterns Are Still Useful&quot; title=&quot;Design Patterns Are Still Useful&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Design patterns gained popularity in computer science after the book Design Patterns: Elements of Reusable Object-Oriented Software was published in 1994 by the so-called “Gang of Four” (Gamma et al.), which is frequently abbreviated as “GoF”. This important book describes various development techniques and pitfalls in addition to providing twenty-three object-oriented programming design patterns. The four authors were Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides.&lt;/p&gt;

&lt;p&gt;In the case of object-oriented programming, design patterns are generally aimed at solving the problems of object generation and interaction, rather than the larger scale problems of overall software architecture. They give generalized solutions in the form of templates that may be applied to real-world problems.&lt;/p&gt;

&lt;p&gt;Design patterns were originally grouped into the categories: creational patterns, structural patterns, and behavioral patterns, and described using the concepts of delegation, aggregation, and consultation.&lt;/p&gt;

&lt;h2 id=&quot;creational-design-patterns&quot;&gt;Creational design patterns&lt;/h2&gt;

&lt;p&gt;These design patterns are all about class instantiation. This pattern can be further divided into class-creation patterns and object-creational patterns. While class-creation patterns use inheritance effectively in the instantiation process, object-creation patterns use delegation effectively to get the job done.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Abstract Factory&lt;/strong&gt;: Creates an instance of several families of classes&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Builder&lt;/strong&gt;: Separates object construction from its representation&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Factory Method&lt;/strong&gt;: Creates an instance of several derived classes&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Object Pool&lt;/strong&gt;: Avoid expensive acquisition and release of resources by recycling objects that are no longer in use&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Prototype&lt;/strong&gt;: A fully initialized instance to be copied or cloned&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Singleton&lt;/strong&gt;: A class of which only a single instance can exist&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;structural-design-patterns&quot;&gt;Structural design patterns&lt;/h2&gt;

&lt;p&gt;These design patterns are all about Class and Object composition. Structural class-creation patterns use inheritance to compose interfaces. Structural object-patterns define ways to compose objects to obtain new functionality.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Adapter&lt;/strong&gt;: Match interfaces of different classes&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Bridge&lt;/strong&gt;: Separates an object’s interface from its implementation&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Composite&lt;/strong&gt;: A tree structure of simple and composite objects&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Decorator&lt;/strong&gt;: Add responsibilities to objects dynamically&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Facade&lt;/strong&gt;: A single class that represents an entire subsystem&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Flyweight&lt;/strong&gt;: A fine-grained instance used for efficient sharing&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Private Class Data&lt;/strong&gt;: Restricts accessor/mutator access&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Proxy&lt;/strong&gt;: An object representing another object&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;behavioral-design-patterns&quot;&gt;Behavioral design patterns&lt;/h2&gt;

&lt;p&gt;These design patterns are all about Class’s objects communication. Behavioral patterns are those patterns that are most specifically concerned with communication between objects.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Chain of responsibility&lt;/strong&gt;: A way of passing a request between a chain of objects&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Command&lt;/strong&gt;: Encapsulate a command request as an object&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Interpreter&lt;/strong&gt;: A way to include language elements in a program&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Iterator&lt;/strong&gt;: Sequentially access the elements of a collection&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Mediator&lt;/strong&gt;: Defines simplified communication between classes&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Memento&lt;/strong&gt;: Capture and restore an object’s internal state&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Null Object&lt;/strong&gt;: Designed to act as a default value of an object&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Observer&lt;/strong&gt;: A way of notifying change to a number of classes&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;State&lt;/strong&gt;: Alter an object’s behavior when its state changes&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Strategy&lt;/strong&gt;: Encapsulates an algorithm inside a class&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Template method&lt;/strong&gt;: Defer the exact steps of an algorithm to a subclass&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Visitor&lt;/strong&gt;: Defines a new operation to a class without change&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;references&quot;&gt;References:&lt;/h6&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://sourcemaking.com/design_patterns&quot;&gt;https://sourcemaking.com/design_patterns&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.blackwasp.co.uk/gofpatterns.aspx&quot;&gt;http://www.blackwasp.co.uk/gofpatterns.aspx&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Software_design_pattern&quot;&gt;https://en.wikipedia.org/wiki/Software_design_pattern&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&quot;books&quot;&gt;Books:&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612&quot;&gt;Design Patterns: Elements of Reusable Object-Oriented Software&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.amazon.com/Head-First-Design-Patterns-Brain-Friendly/dp/0596007124&quot;&gt;Head First Design Patterns: A Brain-Friendly Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 06 Jul 2018 01:00:23 +0300</pubDate>
        <link>http://localhost:4000/2018/software-design-patterns/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/software-design-patterns/</guid>
        
        <category>design patterns</category>
        
        
        <category>design patterns</category>
        
      </item>
    
  </channel>
</rss>
